---
title: "c"
date: 2025-02-05T13:00:00+08:00
draft: false
categories: ["Note","C"]
tags: ["Note","C","C"]
summary: C language
---

c->java/python

c: https://wangdoc.com/clang/intro

# C

https://www.ruanyifeng.com/blog/2006/03/programming_language_evaluations.html

今天在网上看到一篇《[Eric Raymond对于几大程序开发语言的评价](https://www.google.com/search?hl=en&source=hp&q=Eric+Raymond对于几大程序开发语言的评价&btnG=Google+Search&aq=f&aqi=&aql=&oq=&gs_rfai=)》。

我对编程懂的很少，一直想加强学习，就把它转贴过来了。

我的感受是学习程序语言，一定必须从徒手写每一行代码开始学，这样可能是最容易的方法。我最早学的是微软的Visual Basic，按理说BASIC比较简单，应该最好学，可是微软帮你把所有图形界面都做好了，成了一个完全的黑箱，用户等于在对这个黑箱编程，对程序的实际运行流程一点感觉也没有。我学了半年，依然觉得没学会编程。从那时起，我就开始觉得不能跟着微软走了。

后来，我又去学了C语言。这次就从命令行下开始学，一行一行的写，然后再编译。C是公认比较难学的语言，但是我下了决心从最低的起点开始学，学习环境是将近10多年前推出的Turbo C 3.0。虽然我现在C的水平还是很低，但是感觉对C的认识很清楚，许多原理上的问题都理解了。

C编程比较麻烦，我下一门想学perl或者python。我正好有一些想法想实现，急需自编软件处理数据，希望今年之内可以解决掉。

---



**Eric Raymond对于几大程序开发语言的评价**

【译者注】

Eric Raymond是开源运动的领袖人物，对于UNIX开发有很深的造诣，主持开发了fetchmail。他的《大教堂与集市》被奉为开源运动的经典之作。下面对几大开发语言的评价非常中肯，是我近年来看到的比较出色的评论。特别是他评价中抱有的那种"简单就是好"的思想，很值得我们深思。我特别选译出一些段落，供大家阅读思考。原文参见：http://www.catb.org/~esr/writings/taoup/html/ch14s04.html

Raymond此文不是在泛泛地去谈语言的优劣，而是要回答一个问题：在UNIX下开发开源项目，如何选择开发工具？我翻译的很零散，建议大家去看原文。

**C**

虽说C语言在内存管理方面存在严重的缺陷，不过它还是在某些应用领域里称王称霸。对于那些要求最高的效率，良好的实时性，或者与操作系统内核紧密关联的程序来说，C仍然是很好的选择。

C良好的可移植性也为它加了分。不过现在很多其他的语言可移植性越来越好，C在这方面的优势可能会逐渐丧失。

现有的很多程序可以产生非常棒的C代码，比如语法分析器、GUI Builder等，这时候C语言也是有吸引力的，因为你所需要编写的代码只是整个程序的一小部分。

再有，我们当然应该认识道，C语言对于程序员来说具有无可替代的价值。就我这里讨论的每一种语言而论，只要你发掘的足够深，到最后你会看到它们的内核都是用纯正的、可移植的C写成的。

到了今天这个时候，我们最好把C看成是UNIX虚拟机上的高级汇编语言。

就算是其他的高级语言完全可以满足你的工作需要，抽出时间来学习C语言也仍然有益，它能帮助你在硬件体系的层次上思考问题。

即使到了今天，最好的C语言教程仍然是1988年出版的K&R第二版The C Programming Language.

总结：C最出色的地方在于其高效和贴近机器，最糟糕的地方在它的内存管理地狱。

**C++**

C++最初发布于1980年代中期，当时面向对象语言被认为是解决软件复杂性问题的银弹。C++的面向对象特性看相去使其全面超越了C，支持者认为C++将迅速把上一代语言挤到陈列馆里去。

但是历史并非如此。究其原因，至少有一部分归咎于C++本身。为了与C兼容，C++被迫作出了很多重大的设计妥协，结果导致语言过分华丽，过分复杂。为了与C兼容，C++并没有采用自动内存管理的策略，从而丧失了修正C最严重问题的机会。

另外一部分原因，恐怕要算到面向对象身上。看起来OO并没有很好的达成人们当年的预期。我就这个问题调研过，我发现使用OO方法导致组件之间出现很厚的粘合层，并且带来了严重的可维护性问题。今天让我们来看看开放源码社区，你会发现C++的应用还是集中在GUI，游戏和多媒体工具包这些方面，在其他地方很少用到。要知道，面向对象也只是在这些领域被证明非常成功，而开放源码社区的选择，很大程度上体现了程序员的自由意志，而不是公司管理层的胡乱指挥。

也许C++实现OO的方法有问题。有证据表明C++程序在整个生命周期的开销高于相应的C, Fortran和Ada程序。不过，究竟这是否应该归咎与C++的OO实现上，还不清楚。

最近几年，C++加入了很多非OO的思想，其异常思想类似Lisp，STL的出现是非常了不起的。

其实C++最根本的问题在于，它基本上只不过是另一种传统的语言。STL中的内存管理比先前的new/delete和C的方案要好的多，但是还是没有解决问题。对于很多应用程序而言，其OO特性并不明显，相比与C，除了增加复杂度之外没有获得很多好处。

总结：C++优点在于作为编译型语言，把效率与泛型和面向对象特性结合起来，其缺点在于过于华丽复杂，倾向于鼓励程过分复杂的设计。

**Java**

Java的设计很聪明，它采用了自动内存管理，这是最大的改进，支持OO设计带来的好处虽然不那么突出，不过也很值得赞赏，相比C++，其OO设计规模小而且简单 。

相对于Python而言，Java有一些明显的失误。有些地方设计的还是太复杂，甚至有缺陷。Java的类可见性和隐式scoping规则太复杂了。Interface机制是为了避免多继承带来的问题而设计的，但是要理解和使用它还是挺难。内部类和匿名类导致令人困惑的代码。缺乏有效的析构机制，使得除了内存之外的其他资源（比如互斥量和锁）管理起来很困难。Java的线程不可靠，其I/O机制很强大，但是读取一个文本文件却非常繁琐。

Java没有管理库版本的机制，从而形式上重蹈了了Windows DLL地狱的覆辙。在类似应用服务器这样的环境里，这引起了大量的问题。

总体而言，我们可以说除了系统编程和对效率要求极高的程序之外，Java在大部分领域优于C++。经验表明，Java程序员似乎不太容易象C++程序员那样构造过度的OO层，不过在Java中这仍然是个严重问题。

Java是否优于诸如Perl, Python这样的语言？我们还不是很清楚，很大程度上似乎跟程序规模有关。其擅长的领域基本上于Python相似，在效率上无法跟C/C++相提并论，在小规模的、大量使用模式匹配和编辑的项目里也无法匹敌Perl。在小项目里，Java显得过分强大了。我们猜测Python更适合小项目，而Java适合大项目，不过这一点并没有得到有力的证明。

**Python**

Python是一种脚本语言，可以与C紧密整合。它可以与动态加载的C库模块交换数据，也可以作为内嵌脚本语言而从C中调用。其语法类似C和模块化语言的杂合，不过有一个独一无二的特征，就是以缩进来确定语句块。

Python语言非常干净，设计优雅，具有出色的模块化特性。它提供了面向对象能力，但不强迫用户进行面向对象设计。其类型系统提供了强大的表达能力，类似Perl，具有匿名lambda表达式，这点又让Lisp黑客们感到亲切。Python依靠Tk提供方便的GUI界面开发能力。

在所有的解释型语言里，Python和Java最适合多名程序员以渐进方式协同开发大型项目。在很多方面，Python比Java要简单，它非常适合与构造快速原型，这一点使得它对于Java有独特优势：对于那些既不很复杂，又不要求高效率的程序，Python十分合适。

Python的速度没法跟C/C++相比，不过在今天的高速CPU上，合理地使用混合语言编程策略使得Python的上述弱点被有效地弥补。事实上，Python几乎被认为是主流脚本语言中最慢的一个，因为它提供了动态多态性。在大量使用正则表达式的小型项目，它逊于Perl。对于微型项目而言，shell和Tcl可能更好，Python显得太过强大了。

总结：Python最出色的地方在于，它鼓励清晰易读的代码，特别适合以渐进开发的方式构造大项目。其缺陷在于效率不高，太慢，不但跟编译语言相比慢，就是跟其他脚本语言相比也显得慢。

## c语言特点

C 语言能够长盛不衰、广泛应用，主要原因是它有一些鲜明的特点。

（1）低级语言

C 语言能够直接操作硬件、管理内存、跟操作系统对话，这使得它是一种非常接近底层的语言，也就是低级语言，非常适合写需要跟硬件交互、有极高性能要求的程序。

（2）可移植性

C 语言的原始设计目的，是将 Unix 系统移植到其他计算机架构。这使得它从一开始就非常注重可移植性，C 程序可以相对简单地移植到各种硬件架构和操作系统。

除了计算机，C 语言现在还是嵌入式系统的首选编程语言，汽车、照相机、家用电器等设备的底层系统都是用 C 语言编程，这也是因为它良好的可移植性。

（3）简单性

C 语言的语法相对简单，语法规则不算太多，也几乎没有语法糖。一般来说，如果两个语法可以完成几乎相同的事情，C 语言就只会提供一种，这样大大减少了语言的复杂性。

而且，C 语言的语法都是基础语法，不提供高级的数据结构，比如 C 语言没有“类”（class），复杂的数据结构都需要自己构造。

（4）灵活性

C 语言对程序员的限制很少。它假设程序员知道自己在干嘛，不会限制你做各种危险的操作，你干什么都可以，后果也由自己负责。

C 语言的哲学是“信任程序员，不要妨碍他们做事”。比如，它让程序员自己管理内存，不提供内存自动清理功能。另外，也不提供类型检查、数组的负索引检查、指针位置的检查等保护措施。

表面上看，这似乎很危险，但是对于高级程序员来说，却有了更大的编程自由。不过，这也使得 C 语言的 debug 不太容易。

（5）总结

上面这些特点，使得 C 语言可以写出性能非常强、完全发挥硬件潜力的程序，而且 C 语言的编译器实现难度相对较低。但是另一方面，C 语言代码容易出错，一般程序员不容易写好。

此外，当代很多流行语言都是以 C 语言为基础，比如 C++、Java、C#、JavaScript 等等。学好 C 语言有助于对这些语言加深理解。

## 编译

目前，最常见的 C 语言编译器是自由软件基金会推出的 GCC 编译器，它可以免费使用。本书也使用这个编译器。Linux 和 Mac 系统可以直接安装 GCC，Windows 系统可以安装 MinGW。但是，也可以不用这么麻烦，网上有在线编译器，能够直接在网页上模拟运行 C 代码，查看结果，下面就是两个这样的工具。

- CodingGround: https://tutorialspoint.com/compile_c_online.php
- OnlineGDB: https://onlinegdb.com/online_c_compiler

本书的例子都使用 GCC 在命令行进行编译。

## Hello World 示例

C 语言的源代码文件，通常以后缀名`.c`结尾。下面是一个简单的 C 程序`hello.c`。它就是一个普通的文本文件，任何文本编译器都能用来写。

```c
#include <stdio.h>

int main(void) {
  printf("Hello World\n");
  return 0;
}
```

上面这个程序的唯一作用，就是在屏幕上面显示“Hello World”。

这里不讲解这些代码是什么意思，只是作为一个例子，让大家看看 C 代码应该怎么编译和运行。假设你已经安装好了 GCC 编译器，可以打开命令行，执行下面的命令。

```bash
$ gcc hello.c
```

上面命令使用`gcc`编译器，将源文件`hello.c`编译成二进制代码。注意，`$`是命令行提示符，你真正需要输入的是`$`后面的部分。

运行这个命令以后，默认会在当前目录下生成一个编译产物文件`a.out`（assembler output 的缩写，Windows 平台为`a.exe`）。执行该文件，就会在屏幕上输出`Hello World`。

```bash
$ ./a.out
Hello World
```

GCC 的`-o`参数（output 的缩写）可以指定编译产物的文件名。

```
$ gcc -o hello hello.c
```

上面命令的`-o hello`指定，编译产物的文件名为`hello`（取代默认的`a.out`）。编译后就会生成一个名叫`hello`的可执行文件，相当于为`a.out`指定了名称。执行该文件，也会得到同样的结果。

```
$ ./hello
Hello World
```

GCC 的`-std=`参数（standard 的缩写）还可以指定按照哪个 C 语言的标准进行编译。

```
$ gcc -std=c99 hello.c
```

上面命令指定按照 C99 标准进行编译。

注意，`-std`后面需要用`=`连接参数，而不是像上面的`-o`一样用空格，并且`=`前后也不能有多余的空格。

# 基本语法

## printf(): print format

`printf()`可以在输出文本中指定占位符。所谓“占位符”，就是这个位置可以用其他值代入。

常用占位符:

- `%a`：十六进制浮点数，字母输出为小写。
- `%A`：十六进制浮点数，字母输出为大写。
- `%c`：字符。
- `%d`：十进制整数。
- `%e`：使用科学计数法的浮点数，指数部分的`e`为小写。
- `%E`：使用科学计数法的浮点数，指数部分的`E`为大写。
- `%i`：整数，基本等同于`%d`。
- `%f`：小数（包含`float`类型和`double`类型）。
- `%g`：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的`e`为小写。
- `%G`：等同于`%g`，唯一的区别是指数部分的`E`为大写。
- `%hd`：十进制 short int 类型。
- `%ho`：八进制 short int 类型。
- `%hx`：十六进制 short int 类型。
- `%hu`：unsigned short int 类型。
- `%ld`：十进制 long int 类型。
- `%lo`：八进制 long int 类型。
- `%lx`：十六进制 long int 类型。
- `%lu`：unsigned long int 类型。
- `%lld`：十进制 long long int 类型。
- `%llo`：八进制 long long int 类型。
- `%llx`：十六进制 long long int 类型。
- `%llu`：unsigned long long int 类型。
- `%Le`：科学计数法表示的 long double 类型浮点数。
- `%Lf`：long double 类型浮点数。
- `%n`：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。
- `%o`：八进制整数。
- `%p`：指针。
- `%s`：字符串。
- `%u`：无符号整数（unsigned int）。
- `%x`：十六进制整数。
- `%zd`：`size_t`类型。
- `%%`：输出一个百分号。

## 标准库,头文件(header file）

C 语言自带的所有这些功能，统称为“标准库”（standard library），因为它们是写入标准的，到底包括哪些功能，应该怎么使用的，都是规定好的，这样才能保证代码的规范和可移植。



如果要使用某个功能，就必须先加载对应的头文件，加载使用的是`#include`命令。这就是为什么使用`printf()`之前，必须先加载`stdio.h`的原因。

# 变量

变量（variable）可以理解成一块内存区域的名字。通过变量名，可以引用这块内存区域，获取里面存储的值。由于值可能发生变化，所以称为变量，否则就是常量了。

## 变量名

变量名在 C 语言里面属于标识符（identifier），命名有严格的规范。

- 只能由字母（包括大写和小写）、数字和下划线（`_`）组成。

- 不能以数字开头。

- 长度不能超过63个字符。

- 变量名区分大小写

- 非保留字

  ```bash
  auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while
  ```

- 另外，两个下划线开头的变量名，以及一个下划线 + 大写英文字母开头的变量名，都是系统保留的，自己不应该起这样的变量名。

## 变量声明

- C 语言的变量，必须先声明后使用。如果一个变量没有声明，就直接使用，会报错。
- 每个变量都有自己的类型（type）。声明变量时，必须把变量的类型告诉编译器。
- 如果几个变量具有相同类型，可以在同一行声明。
- 声明变量的语句必须以分号结尾。
- 一旦声明，变量的类型就不能在运行时修改

## 变量的赋值

C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。



C 语言有左值（left value）和右值（right value）的概念。左值是可以放在赋值运算符左边的值，一般是变量；右值是可以放在赋值运算符右边的值，一般是一个具体的值。

## 变量的作用域

作用域（scope）指的是变量生效的范围。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。

- 文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。
- 块作用域（block scope）指的是由大括号（`{}`）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。

代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：

- 内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。
- 如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。

# 运算符

运算符`/`用来完成除法。注意，两个整数相除，得到还是一个整数。

运算符`%`表示求模运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数。 负数求模的规则是，结果的正负号由第一个运算数的正负号决定。



C 语言提供两个运算符，对变量自身进行`+ 1`和`- 1`的操作。

- `++`：自增运算符
- `--`：自减运算符

`++var`和`--var`是先执行自增或自减操作，再返回操作后`var`的值；

`var++`和`var--`则是先返回操作前`var`的值，再执行自增或自减操作。





关系表达式通常返回`0`或`1`，表示真伪。C 语言中，`0`表示伪，所有非零值表示真。



逻辑运算符还有一个特点，它总是先对左侧的表达式求值，再对右边的表达式求值，这个顺序是保证的。如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值。这种情况称为“**短路**”。



C 语言提供一些位运算符，用来操作二进制位（bit）。

- 取反运算符`～`是一个一元运算符，用来将每一个二进制位变成相反值，即`0`变成`1`，`1`变成`0`。`~`运算符不会改变变量的值，只是返回一个新的值。
- 与运算符`&`将两个值的每一个二进制位进行比较，返回一个新的值。当两个二进制位都为`1`，就返回`1`，否则返回`0`。
- 或运算符`|`将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位只要有一个为`1`（包含两个都为`1`的情况），就返回`1`，否则返回`0`。
- 异或运算符`^`将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为`1`，就返回`1`，否则返回`0`。
- 左移运算符`<<`将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用`0`填充。
- 右移运算符`>>`将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用`0`填充。

## 运算符优先级

> 完全记住所有运算符的优先级没有必要，解决方法是多用圆括号，防止出现意料之外的情况，也有利于提高代码的可读性。

运算符的优先级顺序很复杂。下面是部分运算符的优先级顺序（按照优先级从高到低排列）。

- 圆括号（`()`）
- 自增运算符（`++`），自减运算符（`--`）
- 一元运算符（`+`和`-`）
- 乘法（`*`），除法（`/`）
- 加法（`+`），减法（`-`）
- 关系运算符（`<`、`>`等）
- 赋值运算符（`=`）

# 流程控制

`if`语句用于条件判断，满足条件时，就执行指定的语句。



C 语言有一个三元表达式`?:`，可以用作`if...else`的简写形式。

```c
<expression1> ? <expression2> : <expression3>
```



switch 语句是一种特殊形式的 if...else 结构，用于判断条件有多个结果的情况。它把多重的`else if`改成更易用、可读性更好的形式。



`while`语句用于循环结构，满足条件时，不断执行循环体。

```c
while (expression)
  statement
```

如果表达式`expression`为非零值（表示真），就会执行`statement`语句，然后再次判断`expression`是否为零；如果`expression`为零（表示伪）就跳出循环，不再执行循环体。



`do...while`结构是`while`的变体，它会先执行一次循环体，然后再判断是否满足条件。如果满足的话，就继续执行循环体，否则跳出循环。

```c
do statement
while (expression);
```



`for`语句是最常用的循环结构，通常用于精确控制循环次数。

```c
for (initialization; continuation; action)
  statement;
```

上面代码中，`for`语句的条件部分（即圆括号里面的部分）有三个表达式。

- `initialization`：初始化表达式，用于初始化循环变量，只执行一次。
- `continuation`：判断表达式，只要为`true`，就会不断执行循环体。
- `action`：循环变量处理表达式，每轮循环结束后执行，使得循环变量发生变化。

循环体部分的`statement`可以是一条语句，也可以是放在大括号里面的复合语句。



`break`语句有两种用法。一种是与`switch`语句配套使用，用来中断某个分支的执行，这种用法前面已经介绍过了。另一种用法是在循环体内部跳出循环，不再进行后面的循环了。

注意，`break`命令只能跳出循环体和`switch`结构，不能跳出`if`结构。



`continue`语句用于在循环体内部终止本轮循环，进入下一轮循环。只要遇到`continue`语句，循环体内部后面的语句就不执行了，回到循环体的头部，开始执行下一轮循环。



# 数据类型

基本数据类型有三种：字符（char）、整数（int）和浮点数（float）。复杂的类型都是基于它们构建的。



C 语言使用`signed`关键字，表示一个类型带有正负号，包含负值；使用`unsigned`关键字，表示该类型不带有正负号，只能表示零和正整数。



有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件`limits.h`提供了相应的常量，比如`SCHAR_MIN`代表 signed char 类型的最小值`-128`，`SCHAR_MAX`代表 signed char 类型的最大值`127`。

为了避免溢出，最好方法就是将运算结果与类型的极限值进行比较。

```c
unsigned int ui;
unsigned int sum;

// 错误
if (sum + ui > UINT_MAX) too_big();
else sum = sum + ui;

// 正确
if (ui > UINT_MAX - sum) too_big();
else sum = sum + ui;
```





C 语言的整数默认都是十进制数，如果要表示八进制数和十六进制数，必须使用专门的表示法。

八进制使用`0`作为前缀，比如`017`、`0377`。

```c
int a = 012; // 八进制，相当于十进制的10
```

十六进制使用`0x`或`0X`作为前缀，比如`0xf`、`0X10`。

```c
int a = 0x1A2B; // 十六进制，相当于十进制的6699
```



C 语言原来并没有为布尔值单独设置一个类型，而是使用整数`0`表示伪，所有非零值表示真。



字面量（literal）指的是代码里面直接出现的值。

常用的字面量后缀有下面这些。

- `f`和`F`：`float`类型。
- `l`和`L`：对于整数是`long int`类型，对于小数是`long double`类型。
- `ll`和`LL`：Long Long 类型，比如`3LL`。
- `u`和`U`：表示`unsigned int`，比如`15U`、`0377U`。





`sizeof`是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。



## 类型的自动转换

某些情况下，C 语言会自动转换某个值的类型。

（1）浮点数赋值给整数变量

浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。

（2）整数赋值给浮点数变量

整数赋值给浮点数变量时，会自动转为浮点数。

（3）窄类型赋值给宽类型

字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升，即窄类型自动转为宽类型。

（4）宽类型赋值给窄类型

字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。





不同类型的值进行混合计算时，必须先转成同一个类型，才能进行计算。转换规则如下：

（1）整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。

（2）不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如`float`转为`double`，`double`转为`long double`。

（3）不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。比如`short`转为`int`，`int`转为`long`等，有时还会将带符号的类型`signed`转为无符号`unsigned`。 (最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将`signed int`转为`unsigned int`，可能不会得到预期的结果。)





原则上，应该避免类型的自动转换，防止出现意料之外的结果。C 语言提供了类型的显式转换，允许手动转换类型。

只要在一个值或变量的前面，使用圆括号指定类型`(type)`，就可以将这个值或变量转为指定的类型，这叫做“类型指定”（casting）。

```c
(unsigned char) ch
```

上面示例将变量`ch`转成无符号的字符类型。

```c
long int y = (long int) 10 + 12;
```

上面示例中，`(long int)`将`10`显式转为`long int`类型。这里的显示转换其实是不必要的，因为赋值运算符会自动将右边的值，转为左边变量的类型。







C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。

程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头文件`stdint.h`创造了一些新的类型别名。

参照: https://wangdoc.com/clang/types 11节



# 指针

> *取值
>
> &取地址
>
> `&`运算符与`*`运算符互为逆运算
>
> 指针本质上就是一个无符号整数，代表了内存地址。

**指针是什么？首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标**。

字符`*`表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，`char*`表示一个指向字符的指针，`float*`表示一个指向`float`类型的值的指针。

```c
int* intPtr;
```

指针变量就是一个普通变量，只不过它的值是内存地址而已。



一个指针指向的可能还是指针，这时就要用两个星号`**`表示。

```c
int** foo;
```



## 运算符

> *取值
>
> &取地址
>
> `&`运算符与`*`运算符互为逆运算
>
> 指针本质上就是一个无符号整数，代表了内存地址。

`*`这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值。

`&`运算符用来取出一个变量所在的内存地址。



## 指针变量的初始化

声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。

```c
int* p;
*p = 1; // 错误
```

正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。

```c
int* p;
int i;

p = &i;
*p = 13;
```

上面示例中，`p`是指针变量，声明这个变量后，`p`会指向一个随机的内存地址。这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数变量`i`，编译器会为`i`分配内存地址，然后让`p`指向`i`的内存地址（`p = &i;`）。完成初始化之后，就可以对`p`指向的内存地址进行赋值了（`*p = 13;`）。

为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为`NULL`。

```c
int* p = NULL;
```

`NULL`在 C 语言中是一个常量，表示地址为`0`的内存空间，这个地址是无法使用的，读写该地址会报错。

# 函数

函数是一段可以重复执行的代码。它可以接受不同的参数，完成对应的操作。



函数声明的语法有以下几点，需要注意。

（1）返回值类型。函数声明时，首先需要给出返回值的类型，上例是`int`，表示函数`plus_one()`返回一个整数。

（2）参数。函数名后面的圆括号里面，需要声明参数的类型和参数名，`plus_one(int n)`表示这个函数有一个整数参数`n`。

（3）函数体。函数体要写在大括号里面，后面（即大括号外面）不需要加分号。大括号的起始位置，可以跟函数名在同一行，也可以另起一行，本书采用同一行的写法。

（4）`return`语句。`return`语句给出函数的返回值，程序运行到这一行，就会跳出函数体，结束函数的调用。如果函数没有返回值，可以省略`return`语句，或者写成`return;`。



函数必须声明后使用，否则会报错。也就是说，一定要在使用`plus_one()`之前，声明这个函数。如果像下面这样写，编译时会报错。

## main()

C 语言规定，`main()`是程序的入口函数，即所有的程序一定要包含一个`main()`函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。

`main()`的写法与其他函数一样，要给出返回值的类型和参数的类型，就像下面这样。

```c
int main(void) {
  printf("Hello World\n");
  return 0;
}
```

C 语言约定，返回值`0`表示函数运行成功，如果返回其他非零整数，就表示运行失败，代码出了问题。系统根据`main()`的返回值，作为整个程序的返回值，确定程序是否运行成功。

正常情况下，如果`main()`里面省略`return 0`这一行，编译器会自动加上，即`main()`的默认返回值为0。



由于 C 语言只会对`main()`函数默认添加返回值，对其他函数不会这样做，所以建议总是保留`return`语句，以便形成统一的代码风格。

## 参数传递的引用

如果函数的参数是一个变量，那么调用时，传入的是这个变量的值的拷贝，而不是变量本身

```c
void increment(int a) {
  a++;
}

int i = 10;
increment(i);

printf("%d\n", i); // 10
```

上面示例中，调用`increment(i)`以后，变量`i`本身不会发生变化，还是等于`10`。因为传入函数的是`i`的拷贝，而不是`i`本身，拷贝的变化，影响不到原始变量。这就叫做“传值引用”。



如果想要传入变量本身，只有一个办法，就是传入变量的地址。



## 函数指针

> 引用,快捷方式

函数本身就是一段内存里面的代码，C 语言允许通过指针获取函数。



比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，`print`和`&print`是一回事。

为了简洁易读，一般情况下，函数名前面都不加`*`和`&`。



## 函数原型

前面说过，函数必须先声明，后使用。由于程序总是先运行`main()`函数，导致所有其他函数都必须在`main()`函数之前声明。



但是，`main()`是整个程序的入口，也是主要逻辑，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。

C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。

```c
int twice(int);

int main(int num) {
  return twice(num);
}

int twice(int num) {
  return 2 * num;
}
```

注意，函数原型必须以分号结尾。

一般来说，每个源码文件的头部，都会给出当前脚本使用的所有函数的原型。



**函数原型**

> **函数原型 = 返回类型 + 函数名 + 参数列表**
>
> **推荐使用函数原型**，特别是在大型项目或多文件编程时
>
> **可用于启用编译器的类型检查**，减少错误

在 C 语言中，**函数原型（Function Prototype）**用于声明函数的返回类型、函数名和参数列表，使编译器在调用函数时能够进行类型检查。



作用

- **提前告知编译器函数的返回类型和参数类型**，避免隐式声明导致的错误。
- **支持分离编译**，即函数可以在多个源文件中定义和调用，而不需要按顺序出现。
- **启用编译器的类型检查**，防止参数类型不匹配的错误。



## exit()

`exit()`函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件`stdlib.h`里面。

```c
// 程序运行成功
// 等同于 exit(0);
exit(EXIT_SUCCESS);

// 程序异常中止
// 等同于 exit(1);
exit(EXIT_FAILURE);
```

在`main()`函数里面，`exit()`等价于使用`return`语句。其他函数使用`exit()`，就是终止整个程序的运行，没有其他作用。

C 语言还提供了一个`atexit()`函数，用来登记(注册)`exit()`执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件`stdlib.h`。

```c
void print(void) {
  printf("something wrong!\n");
}

atexit(print);
exit(EXIT_FAILURE);
```

## 函数说明符

extern

对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并用`extern`说明该函数的定义来自其他文件。

不过，由于函数原型默认就是`extern`，所以这里不加`extern`，效果是一样的。



static

默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。`static`说明符可以改变这种行为。

`static`用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。

```c
#include <stdio.h>

void counter(void) {
  static int count = 1;  // 只初始化一次
  printf("%d\n", count);
  count++;
}

int main(void) {
  counter();  // 1
  counter();  // 2
  counter();  // 3
  counter();  // 4
}
```

在块作用域中，`static`声明的变量有默认值`0`

`static`可以用来修饰函数本身。

`static`也可以用在参数里面，修饰参数数组。



const

函数参数里面的`const`说明符，表示函数内部不得修改该参数变量。



## 可变参数

有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号`...`表示可变数量的参数。

```c
int printf(int i, ...);
```

注意，`...`符号必须放在参数序列的结尾，否则会报错。



头文件`stdarg.h`定义了一些宏，可以操作可变参数。

（1）`va_list`：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。

（2）`va_start`：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。

（3）`va_arg`：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。

（4）`va_end`：一个函数，用来清理可变参数对象。

# 数组

数组是一组相同类型的值，按照顺序储存在一起。数组通过变量名后加方括号表示，方括号里面是数组的成员数量。

```c
int scores[100];
```

声明初始化

C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度

```c
int a[] = {22, 37, 3490};
// 等同于
int a[3] = {22, 37, 3490};
```



## 数组长度

`sizeof`运算符会返回整个数组的字节长度。

由于数组成员都是同一个类型，每个成员的字节长度都是一样的，所以数组整体的字节长度除以某个数组成员的字节长度，就可以得到数组的成员数量。

```C
sizeof(a) / sizeof(a[0])
```

上面示例中，`sizeof(a)`是整个数组的字节长度，`sizeof(a[0])`是数组成员的字节长度，相除就是数组的成员数量。







## 多维数组

C 语言允许声明多个维度的数组，有多少个维度，就用多少个方括号，比如二维数组就使用两个方括号。

```c
int board[10][10];
```

上面示例声明了一个二维数组，第一个维度有10个成员，第二个维度也有10个成员。

多维数组可以理解成，上层维度的每个成员本身就是一个数组。比如上例中，第一个维度的每个成员本身就是一个有10个成员的数组，因此整个二维数组共有100个成员（10 x 10 = 100）。

三维数组就使用三个方括号声明，以此类推。



## 变长数组

数组声明的时候，数组长度除了使用常量，也可以使用变量。这叫做变长数组（variable-length array，简称 VLA）。

```c
int n = x + y;
int arr[n];
```

上面示例中，数组`arr`就是变长数组，因为它的长度取决于变量`n`的值，编译器没法事先确定，只有运行时才能知道`n`是多少。

变长数组的根本特征，就是数组长度只有运行时才能确定。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。



## 数组指针的加减法

C 语言里面，数组名可以进行加法和减法运算，等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址。比如，`a + 1`返回下一个成员的地址，`a - 1`返回上一个成员的地址。

```c
int a[5] = {11, 22, 33, 44, 55};

for (int i = 0; i < 5; i++) {
  printf("%d\n", *(a + i));
}
```

上面示例中，**通过指针的移动遍历数组，`a + i`的每轮循环每次都会指向下一个成员的地址，`*(a + i)`取出该地址的值，**等同于`a[i]`。对于数组的第一个成员，`*(a + 0)`（即`*a`）等同于`a[0]`。

由于数组名与指针是等价的，所以下面的等式总是成立。

```c
a[b] == *(a + b)
```

上面代码给出了数组成员的两种访问方式，一种是使用方括号`a[b]`，另一种是使用指针`*(a + b)`。

如果指针变量`p`指向数组的一个成员，那么`p++`就相当于指向下一个成员，这种方法常用来遍历数组。

```c
int a[] = {11, 22, 33, 44, 55, 999};

int* p = a;

while (*p != 999) {
  printf("%d\n", *p);
  p++;
}
```

上面示例中，通过`p++`让变量`p`指向下一个成员。



同一个数组的两个成员的指针相减时，返回它们之间的距离。



## 数组的复制

由于数组名是指针，所以复制数组不能简单地复制数组名。

```c
int* a;
int b[3] = {1, 2, 3};

a = b;
```

上面的写法，结果不是将数组`b`复制给数组`a`，而是让`a`和`b`指向同一个数组。

复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。

```c
for (i = 0; i < N; i++)
  a[i] = b[i];
```

上面示例中，通过将数组`b`的成员逐个复制给数组`a`，从而实现数组的赋值。

另一种方法是使用`memcpy()`函数（定义在头文件`string.h`），直接把数组所在的那一段内存，再复制一份。

```c
memcpy(a, b, sizeof(b));
```

上面示例中，将数组`b`所在的那段内存，复制给数组`a`。这种方法要比循环复制数组成员要快。

## 作为函数的参数

数组作为函数的参数，一般会同时传入数组名和数组长度。

```c
int sum_array(int a[],int n){
    int sum=0;
    for (int i = 0; i < n; i++)
    {
        // sum+=*(a+i);
        sum+=a[i];
    }
    return sum;
    
}

int main(void){
    int a[]={1,2,3,4,5};
    int sum=sum_array(a,4);
    printf("%d",sum);
}
```

上面示例中，函数`sum_array()`的第一个参数是数组本身，也就是数组名，第二个参数是数组长度。

由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。

# 字符串

C 语言没有单独的字符串类型，字符串被当作字符数组，即`char`类型的数组。比如，字符串“Hello”是当作数组`{'H', 'e', 'l', 'l', 'o'}`处理的。



编译器会给数组分配一段连续内存，所有字符储存在相邻的内存单元之中。在字符串结尾，C 语言会自动添加一个全是二进制`0`的字节，写作`\0`字符，表示字符串结束。

```c
{'H', 'e', 'l', 'l', 'o', '\0'}

// 等价于
"Hello"
```

字符串写成数组的形式，是非常麻烦的。C 语言提供了一种简写法，双引号之中的字符，会被自动视为字符数组。



## 字符串变量的声明

字符串变量可以声明成一个字符数组，也可以声明成一个指针，指向字符数组。

```c
// 写法一: 
// 字符数组变量不能指向另一个字符串。 字符数组的数组名，总是指向初始化时的字符串地址，不能修改。
char s[14] = "Hello, world!";

// 写法二: 
// 指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。
// 指针变量可以指向其它字符串。
char* s = "Hello, world!";
```

上面两种写法都声明了一个字符串变量`s`。如果采用第一种写法，由于字符数组的长度可以让编译器自动计算，所以声明时可以省略字符数组的长度。

```c
char s[] = "Hello, world!";
```



想要重新赋值，必须使用 C 语言原生提供的`strcpy()`函数，通过字符串拷贝完成赋值。这样做以后，**数组变量的地址还是不变的，即`strcpy()`只是在原地址写入新的字符串，而不是让数组变量指向新的地址。**

```c
char s[10];
strcpy(s, "abc");
```

## strlen()

strlen()`函数返回字符串的字节长度，不包括末尾的空字符`\0

`strlen()`的原型在标准库的`string.h`文件中定义，使用时需要加载头文件`string.h`。

注意，字符串长度（`strlen()`）与字符串变量长度（`sizeof()`），是两个不同的概念。



如果不使用这个函数，可以通过判断字符串末尾的`\0`，自己计算字符串长度。

```c
int my_strlen(char *s) {
  int count = 0;
  while (s[count] != '\0')
    count++;
  return count;
}
```

## ~~strcpy()~~

字符串的复制，不能使用赋值运算符，直接将一个字符串赋值给字符数组变量。

`strcpy()`的返回值是一个字符串指针（即`char*`），指向第一个参数。

`strcpy()`函数有安全风险，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。如果不能保证不会发生溢出，建议使用`strncpy()`函数代替。

```c
strcpy(char dest[], const char source[])
```

## strncpy()

`strncpy()`跟`strcpy()`的用法完全一样，只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。

```c
char* strncpy(
  char* dest, 
  char* src, 
  size_t n
);
```

eg
```c
char s1[40];
char s2[12] = "hello world";

strncpy(s1, s2, 5);
s1[5] = '\0';

printf("%s\n", s1); // hello
```

## ~~strcat()~~

`strcat()`函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。这个函数会改变第一个字符串，但是第二个字符串不变。

```c
char* strcat(char* s1, const char* s2);
```

## strncat()

`strncat()`用于连接两个字符串，用法与`strcat()`完全一致，只是增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串中遇到空字符`\0`，就不再添加了。它的原型定义在`string.h`头文件里面。

```c
char* strncat(
  const char* dest,
  const char* src,
  size_t n
);
```



`strncat()`返回第一个参数，即目标字符串指针。

为了保证连接后的字符串，不超过目标字符串的长度，`strncat()`通常会写成下面这样。

```c
strncat(
  str1, 
  str2, 
  sizeof(str1) - strlen(str1) - 1
);
```

## strcmp()

如果要比较两个字符串，无法直接比较，只能一个个字符进行比较，C 语言提供了`strcmp()`函数。

```c
int strcmp(const char* s1, const char* s2);
```

## strncmp()

由于`strcmp()`比较的是整个字符串，C 语言又提供了`strncmp()`函数，只比较到指定的位置。



## sprintf()，snprintf()

`sprintf()`函数跟`printf()`类似，但是用于将数据写入字符串，而不是输出到显示器。该函数的原型定义在`stdio.h`头文件里面。



# c语言的内存管理

> 系统管理: 函数内部的变量（局部变量）所在的内存 stack(栈)
>
> 用户手动管理: 程序运行的整个过程中都存在的变量(全局变量)所在的内存, heap(堆)

C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。

系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。

用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。



## void指针

向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。

为了满足这种需求，C 语言提供了一种不定类型的指针，叫做 void 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。



另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。void 指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针。



## malloc()

`malloc()`函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件`stdlib.h`。



由于存在分配失败的可能，所以最好在使用`malloc()`之后检查一下，是否分配成功。

```c
int* p = malloc(sizeof(int));

if (p == NULL) {
  // 内存分配失败
}

// or
if (!p) {
  //...
}
```

`malloc()`最常用的场合，就是为数组和自定义数据结构分配内存。

```c
int* p = (int*) malloc(sizeof(int) * 10);

for (int i = 0; i < 10; i++)
  p[i] = i * 5;
```

上面示例中，`p`是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。

`malloc()`用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。

```c
int* p = (int*) malloc(n * sizeof(int));
```

上面示例中，`malloc()`可以根据变量`n`的不同，动态为数组分配不同的大小。

注意，`malloc()`不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用`strcpy()`函数。

```c
char* p = malloc(4);
strcpy(p, "abc");
```

上面示例中，字符指针`p`指向一段4个字节的内存，`strcpy()`将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化。



## free()

`free()`用于释放`malloc()`函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件`stdlib.h`里面。

```
void free(void* block)
```

## `malloc`、`calloc` 和 `realloc`

`malloc`、`calloc` 和 `realloc` 是 C 语言中用于动态内存分配的标准库函数，它们的主要区别如下：

| 函数                                  | 功能                          | 内存初始化                                       | 适用场景                               |
| ------------------------------------- | ----------------------------- | ------------------------------------------------ | -------------------------------------- |
| `malloc(size_t size)`                 | 分配 `size` 字节的内存        | **不初始化**，内容是**不确定**的（可能是脏数据） | 需要分配一块连续的内存，但不关心初始值 |
| `calloc(size_t num, size_t size)`     | 分配 `num * size` 字节的内存  | **初始化为 0**（所有字节均置零）                 | 需要分配内存并初始化，例如分配数组     |
| `realloc(void *ptr, size_t new_size)` | 重新调整 `ptr` 指向的内存大小 | **不初始化新增的部分**                           | 需要调整已有内存大小（扩展或缩小）     |

## `restrict`说明符

声明指针变量时，可以使用`restrict`说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。

```c
int* restrict p;
p = malloc(sizeof(int));
```

上面示例中，声明指针变量`p`时，加入了`restrict`说明符，使得`p`变成了受限指针。后面，当`p`指向`malloc()`函数返回的一块内存区域，就意味着，该区域只有通过`p`来访问，不存在其他访问方式。



## memory操作

`memcpy()`用于将一块内存拷贝到另一块内存

`memmove()`函数用于将一段内存数据复制到另一段内存。它跟`memcpy()`的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与`memcpy()`行为相同。

`memcmp()`函数用来比较两个内存区域

# struct结构

C 语言提供了`struct`关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C 语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能。

```c
struct fraction {
  int numerator;
  int denominator;
};
```

上面示例定义了一个分数的数据类型`struct fraction`，包含两个属性`numerator`和`denominator`。



定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。

> 声明自定义类型的变量时，类型名前面，不要忘记加上`struct`关键字。也就是说，必须使用`struct fraction f1`声明变量，不能写成`fraction f1`。

```c
struct fraction f1;

f1.numerator = 22;
f1.denominator = 7;
```

除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值。

```c
struct car {
  char* name;
  float price;
  int speed;
};

struct car saturn = {"Saturn SL/2", 16000.99, 175};
```

上面示例中，变量`saturn`是`struct car`类型，大括号里面同时对它的三个属性赋值。如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为`0`。

注意，大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。

```c
struct car saturn = {.speed=172, .name="Saturn SL/2"};
```

struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。

```c
struct book {
  char title[500];
  char author[100];
  float value;
} b1;
```

下一章介绍的`typedef`命令可以为 struct 结构指定一个别名，这样使用起来更简洁。

```c
typedef struct cell_phone {
  int cell_no;
  float minutes_of_charge;
} phone;

phone p = {5551234, 5};
```



struct 结构占用的存储空间，不是各个属性存储空间的总和，而是**最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐**。这样可以提高读写效率。

```c
struct foo {
  int a;
  char* b;
  char c;
};
printf("%d\n", sizeof(struct foo)); // 24
```

为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。



由于这个特性，在有必要的情况下，定义 Struct 结构体时，**可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。**

```c
struct foo {
  char c;
  int a;
  char* b;
};
printf("%d\n", sizeof(struct foo)); // 16
```

上面示例中，占用空间最小的`char c`排在第一位，其次是`int a`，占用空间最大的`char* b`排在最后。整个`strct foo`的内存占用就从24字节下降到16字节。

## struct 的复制

struct 变量可以使用赋值运算符（`=`），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。

```c
struct cat { char name[30]; short age; } a, b;

strcpy(a.name, "Hula");
a.age = 3;

b = a;
b.name[0] = 'M';

printf("%s\n", a.name); // Hula
printf("%s\n", b.name); // Mula
```

上面示例中，变量`b`是变量`a`的副本，两个变量的值是各自独立的，修改掉`b.name`不影响`a.name`。



## struct 指针

如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。

```c
#include <stdio.h>

struct turtle {
  char* name;
  char* species;
  int age;
};

void happy(struct turtle t) {
  t.age = t.age + 1;
}

int main() {
  struct turtle myTurtle = {"MyTurtle", "sea turtle", 99};
  happy(myTurtle);
  printf("Age is %i\n", myTurtle.age); // 输出 99
  return 0;
}
```

通常情况下，开发者希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将 struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部。

struct 指针传入函数的写法如下。

```c
void happy(struct turtle* t) {
}

happy(&myTurtle);
```

上面代码中，`t`是 struct 结构的指针，调用函数时传入的是指针。struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成`&myTurtle`。

函数内部也必须使用`(*t).age`的写法，从指针拿到 struct 结构本身。

```c
void happy(struct turtle* t) {
  (*t).age = (*t).age + 1;
}
```

`(*t).age`这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（`->`），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。

```c
void happy(struct turtle* t) {
  t->age = t->age + 1;
}
```

总结一下，对于 struct 变量名，使用点运算符（`.`）获取属性；对于 struct 变量指针，使用箭头运算符（`->`）获取属性。以变量`myStruct`为例，假设`ptr`是它的指针，那么下面三种写法是同一回事。

```c
// ptr == &myStruct
myStruct.prop == (*ptr).prop == ptr->prop
```

## struct 的嵌套

struct 结构内部不仅可以引用其他结构，还可以自我引用，即结构内部引用当前结构。比如，链表结构的节点就可以写成下面这样。

```c
struct node {
  int data;
  struct node* next;
};
```

上面示例中，`node`结构的`next`属性，就是指向另一个`node`实例的指针。下面，使用这个结构自定义一个数据链表。

```c
struct node {
  int data;
  struct node* next;
};

struct node* head;

// 生成一个三个节点的列表 (11)->(22)->(33)
head = malloc(sizeof(struct node));

head->data = 11;
head->next = malloc(sizeof(struct node));

head->next->data = 22;
head->next->next = malloc(sizeof(struct node));

head->next->next->data = 33;
head->next->next->next = NULL;

// 遍历这个列表
for (struct node *cur = head; cur != NULL; cur = cur->next) {
  printf("%d\n", cur->data);
}
```

上面示例是链表结构的最简单实现，通过`for`循环可以对其进行遍历。

# typedef命令

`typedef`命令用来为某个类型起别名。

```c
typedef type name;
```

上面代码中，`type`代表类型名，`name`代表别名。





（1）更好的代码可读性。

```
typedef char* STRING;

STRING name;
```

上面示例为字符指针起别名为`STRING`，以后使用`STRING`声明变量时，就可以轻易辨别该变量是字符串。







(2)typedef 也可以与 struct 定义数据类型的命令写在一起。

```c
typedef struct animal {
  char* name;
  int leg_count, speed;
} animal;
```

上面示例中，自定义数据类型时，同时使用`typedef`命令，为`struct animal`起了一个别名`animal`。

这种情况下，C 语言允许省略 struct 命令后面的类型名。

```c
typedef struct {
  char *name;
  int leg_count, speed;
} animal;
```

上面示例相当于为一个匿名的数据类型起了别名`animal`。

（3）typedef 方便以后为变量改类型。

```c
typedef float app_float;

app_float f1, f2, f3;
```

上面示例中，变量`f1`、`f2`、`f3`的类型都是`float`。如果以后需要为它们改类型，只需要修改`typedef`语句即可。

```c
typedef long double app_float;
```

上面命令将变量`f1`、`f2`、`f3`的类型都改为`long double`。

（4）可移植性

```c
int32_t i = 100000;
```

上面示例将变量`i`声明成`int32_t`类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。

这一类的类型别名都是用 typedef 定义的。下面是类似的例子。

```c
typedef long int ptrdiff_t;
typedef unsigned long int size_t;
typedef int wchar_t;
```

这些整数类型别名都放在头文件`stdint.h`，不同架构的计算机只需修改这个头文件即可，而无需修改代码。

因此，`typedef`有助于提高代码的可移植性，使其能适配不同架构的计算机。

（5）简化类型声明

# Union 结构

> 声明->要用哪个属性先赋值

C 语言提供了 Union 结构，用来自定义可以灵活变更的数据结构。它内部包含各种属性，但是所有属性共用一块内存，导致这些属性都是对同一个二进制数据的解读，其中往往只有一个属性的解读是有意义的。并且，后面写入的属性会覆盖前面的属性，这意味着同一块内存，可以先供某一个属性使用，然后再供另一个属性使用。这样做的最大好处是节省内存空间。

```c
union quantity {
  short count;
  float weight;
  float volume;
};
```

# Enum 类型

如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，为了提高代码的可读性，可以将它们定义为 Enum 类型，中文名为枚举。

```c
enum colors {RED, GREEN, BLUE};

printf("%d\n", RED); // 0
printf("%d\n", GREEN);  // 1
printf("%d\n", BLUE);  // 2
```

Enum 的作用域与变量相同。如果是在顶层声明，那么在整个文件内都有效；如果是在代码块内部声明，则只对该代码块有效。如果与使用`int`声明的常量相比，Enum 的好处是更清晰地表示代码意图。

# 预处理器

C 语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。

预处理器首先会清理代码，进行删除注释、多行语句合成一个逻辑行等工作。然后，执行`#`开头的预处理指令。本章介绍 C 语言的预处理指令。

预处理指令可以出现在程序的任何地方，但是习惯上，往往放在代码的开头部分。

每个预处理指令都以`#`开头，放在一行的行首，指令前面可以有空白字符（比如空格或制表符）。`#`和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格。

所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。

## #define

`#define`是最常见的预处理指令，用来将指定的词替换成另一个词。

## 带参数的宏

宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。

```c
#define SQUARE(X) X*X
```

上面示例中，宏`SQUARE`可以接受一个参数`X`，替换成`X*X`。

```c
// 替换成 z = 2*2;
z = SQUARE(2);
```





那么，什么时候使用带参数的宏，什么时候使用函数呢？

一般来说，应该首先使用函数，它的功能更强、更容易理解。宏有时候会产生意想不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差。

宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。



**#运算符，##运算符**

由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上`#`。



`##`运算符的一个主要用途是批量生成变量名和标识符。



**不定参数的宏**

宏的参数还可以是不定数量的（即不确定有多少个参数），`...`表示剩余的参数。

```
#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__
```

上面示例中，`X(a, b, ...)`表示`X()`至少有两个参数，多余的参数使用`...`表示。在替换文本中，`__VA_ARGS__`代表多余的参数（每个参数之间使用逗号分隔）。下面是用法示例。



**`#undef`**

`#undef`指令用来取消已经使用`#define`定义的宏。

## #include

`#include`指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。

```
// 形式一
#include <foo.h> // 加载系统提供的文件

// 形式二
#include "foo.h" // 加载用户提供的文件
```

## #if...#endif

`#if...#endif`指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。

```
#if 0
  const double pi = 3.1415; // 不会执行
```

## \#ifdef...#endif

有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用`#define`定义一个空的宏。通过这个宏，判断库文件是否被加载了。

```c
#define EXTRA_HAPPY
```

上面示例中，`EXTRA_HAPPY`就是一个空的宏。

然后，源码文件使用`#ifdef...#endif`检查这个宏是否定义过。

```c
#ifdef EXTRA_HAPPY
  printf("I'm extra happy!\n");
#endif
```

## defined 运算符

这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。



## 预定义宏

C 语言提供一些预定义的宏，可以直接使用。

- `__DATE__`：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。
- `__TIME__`：编译时间，格式为“hh:mm:ss”。
- `__FILE__`：当前文件名。
- `__LINE__`：当前行号。
- `__func__`：当前正在执行的函数名。该预定义宏必须在函数作用域使用。
- `__STDC__`：如果被设为1，表示当前编译器遵循 C 标准。
- `__STDC_HOSTED__`：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。
- `__STDC_VERSION__`：编译所使用的 C 语言版本，是一个格式为`yyyymmL`的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。

```c
#include <stdio.h>

int main(void) {
  printf("This function: %s\n", __func__);
  printf("This file: %s\n", __FILE__);
  printf("This line: %d\n", __LINE__);
  printf("Compiled on: %s %s\n", __DATE__, __TIME__);
  printf("C Version: %ld\n", __STDC_VERSION__);
}

/* 输出如下

This function: main
This file: test.c
This line: 7
Compiled on: Mar 29 2021 19:19:37
C Version: 201710

*/
```

## #error

`#error`指令用于让预处理器抛出一个错误，终止编译。

```c
#if __STDC_VERSION__ != 201112L
  #error Not C11
#endif
```

上面示例指定，如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错。

```bash
$ gcc -std=c99 newish.c
newish.c:14:2: error: #error Not C11
```

# I/O函数

C 语言提供了一些函数，用于与外部设备通信，称为输入输出函数，简称 I/O 函数。输入（import）指的是获取外部数据，输出（export）指的是向外部传递数据。

## 缓存和字节流

> 打开一个文件->在内存里为这个文件设置缓存区->写入数据到文件,先放在缓存->缓存满了,一次性写入磁盘,清空缓存->...

严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。这个小节介绍缓存是什么。



C 语言的输入输出函数，凡是涉及读写文件，都是属于字节流操作。输入函数从文件获取数据，操作的是输入流；输出函数向文件写入数据，操作的是输出流。

## printf()

`printf()`是最常用的输出函数，用于屏幕输出

## scanf()

`scanf()`函数用于读取用户的键盘输入。程序运行到这个语句时，会停下来，等待用户从键盘输入。用户输入数据、按下回车键后，`scanf()`就会处理用户的输入，将其存入变量。



`scanf()`常用的占位符如下，与`printf()`的占位符基本一致。

- `%c`：字符。
- `%d`：整数。
- `%f`：`float`类型浮点数。
- `%lf`：`double`类型浮点数。
- `%Lf`：`long double`类型浮点数。
- `%s`：字符串。
- `%[]`：在方括号中指定一组匹配的字符（比如`%[0-9]`），遇到不在集合之中的字符，匹配将会停止。

## sscanf()

`sscanf()`函数与`scanf()`很类似，不同之处是`sscanf()`从字符串里面，而不是从用户输入获取数据。它的原型定义在头文件`stdio.h`里面。

```c
int sscanf(const char* s, const char* format, ...);
```

